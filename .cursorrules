# Cursor Project Rules — Spiral Thirsty Take-Home Challenge

# Purpose: Guide Cursor to generate code that aligns with Spiral's expectations,

# the provided PDF spec, and senior-level frontend assessment criteria.

---

## 1. Core Principles (Highest Priority)

- Follow the **PDF requirements exactly** before adding enhancements.
- Prefer **clarity and correctness** over clever abstractions.
- Optimize for **readability, maintainability, and reviewability**.
- Avoid speculative features or premature optimization.
- Treat this as **production-quality frontend code**, not a demo.
- Focus on **functionality over pixel-perfect design**.
- **Clean, readable code is more important than visual polish**.
- **Prioritize working features over perfect styling**.
- Make **pragmatic architectural decisions** that balance simplicity and maintainability.
- Handle edge cases gracefully without over-engineering.

---

## 2. Required Technology Constraints (DO NOT VIOLATE)

Cursor MUST:

- Use **Next.js with the App Router**
- Use **TypeScript** with strict typing
- Use **React 18** function components
- Use **Chakra UI** for all layout and styling
- Use **@tanstack/react-query** for API data fetching
- Use the **CocktailDB REST API** only

Cursor MUST NOT:

- Introduce Redux, Zustand, or other global state libraries
- Use inline styles or CSS files instead of Chakra props
- Use class-based React components
- Use axios unless explicitly requested
- Bypass TypeScript with `any`

---

## 3. Project Structure Rules

Cursor must follow this structure unless explicitly instructed otherwise:

src/
app/
layout.tsx
page.tsx # Search screen
drinks/[id]/page.tsx # Details screen

components/
SearchBar.tsx
DrinkList.tsx
DrinkListItem.tsx
IngredientLegend.tsx
IngredientsPieChart.tsx
LoadingState.tsx

hooks/
useDrinkSearch.ts
useDrinkDetails.ts

lib/
api.ts # API calls only
ingredientUtils.ts # unit conversion + filtering
colorUtils.ts # pastel color generation

types/
cocktail.ts

theme/
index.ts

**tests**/
ingredientUtils.test.ts

---

## 4. Data Fetching Rules

- All API calls MUST be defined in `lib/api.ts`
- React Query hooks MUST live in `hooks/`
- Query keys must be stable and descriptive
  - Example: `["drinks", searchTerm]`
- Do NOT fetch directly inside components

---

## 5. Ingredient & Measurement Handling Rules

Cursor MUST:

- Normalize ingredient data from `strIngredientX` / `strMeasureX`
- Convert all supported units into **milliliters (ml)**
- Exclude unsupported or malformed units from the pie chart
- Handle partial or missing ingredient data gracefully

Cursor MUST NOT:

- Assume API data is clean or consistent
- Crash when measurements are missing

---

## 6. UI & Layout Rules (Chakra UI)

- All layout must use Chakra primitives (`Flex`, `Box`, `Stack`, etc.)
- Respect spacing, sizing, and hierarchy from the PDF spec
- Fixed list row height: **60px**
- Images must be circular using Chakra props
- Typography must use Chakra `Text` with explicit font sizes

Do NOT over-design. Keep UI clean and minimal.

---

## 7. Pie Chart & Legend Rules

- Pie chart must only include convertible ingredients
- Ingredient colors must be:
  - Random but deterministic per ingredient
  - Pastel-toned if possible
- Legend colors must match pie chart colors exactly
- Chart size must be ~120px

---

## 8. State Management Rules

- React Query handles server state ONLY
- Local `useState` allowed for:
  - Search input
  - UI-only concerns
- No global app state

---

## 9. Error Handling Philosophy

- Network error handling is NOT required
- UI must gracefully handle:
  - Empty search results
  - Missing images
  - Partial ingredient data

Do NOT overbuild error states.

---

## 10. Testing Rules

Cursor MUST:

- **Write appropriate tests when completing a task** - Every completed feature, utility function, or API integration MUST have corresponding tests
- **Place tests in the correct location**:
  - Unit tests for utilities → `src/tests/[utilityName].test.ts` (e.g., `src/tests/ingredientUtils.test.ts`)
  - API integration tests → `src/tests/api.test.ts`
  - Component tests → `src/tests/[componentName].test.tsx` (if using React Testing Library)
  - E2E tests → `e2e/[feature].spec.ts` (using Playwright)
- **Test the right things**:
  - Pure functions and utilities MUST have unit tests
  - API functions MUST have integration tests verifying response structure
  - Complex business logic MUST have tests
  - Edge cases and error handling MUST be tested
- **Prefer testing pure functions and utilities** over UI components
- **Use Vitest for unit/integration tests** - Tests should be in `src/tests/` directory
- **Use Playwright for E2E tests** - Tests should be in `e2e/` directory

Cursor SHOULD:

- Write tests that verify:
  - Function returns expected output for given inputs
  - Edge cases are handled correctly
  - Type safety is maintained
  - API responses match TypeScript types
- Keep tests focused and readable
- Use descriptive test names that explain what is being tested

Cursor MUST NOT:

- Skip writing tests for completed functionality
- Add excessive or redundant test coverage
- Use snapshot testing (prefer explicit assertions)
- Write tests that are overly complex or hard to understand

---

## 11. Storybook Rules (Optional Extra Credit)

If Storybook is added:

- Include at least one component story
- Prefer `DrinkListItem` or `IngredientLegend`
- Keep stories simple and focused

---

## 12. README Expectations

Cursor MUST generate a README that includes:

- Project overview
- Setup instructions
- API reference
- Architectural decisions
- Trade-offs and assumptions
- Deployment URL (if available)

---

## 13. Code Review Readiness Rules

Before generating or modifying code, Cursor must:

- **ALWAYS check for existing implementations first** - Search the codebase for similar functionality before creating new code
- **Extend existing utilities instead of duplicating logic** - Reuse and extend rather than recreate
- **Avoid unused code or speculative helpers** - Only create what is needed
- **Ensure the project builds without errors** - Verify compilation before completing
- Write code that is **defensible during a lead engineer review**
- Make decisions that can be **explained and justified** if questioned
- Structure code to be **copyable, extensible, and maintainable**

**When completing a task, Cursor MUST:**

- **Write appropriate tests** - See section 10 for testing requirements
- **Place tests in the correct file** - Follow the test file naming and location conventions
- **Verify tests pass** - Run `npm run test:run` to ensure all tests pass before marking task complete
- **Update existing tests if needed** - If functionality changes, update related tests accordingly

---

## 13a. DRY (Don't Repeat Yourself) Principles

Cursor MUST follow DRY principles:

- **Component Reusability**: Before creating a new component, check if an existing component can be extended or reused
- **Utility Functions**: Extract repeated logic into shared utility functions in `lib/`
- **Shared Types**: Use existing type definitions from `types/` instead of redefining
- **Hook Reusability**: Create reusable hooks in `hooks/` for shared state or data fetching patterns
- **Avoid Duplication**: If similar code exists in multiple places, refactor into a shared utility or component
- **Composition Over Duplication**: Compose existing components rather than copying their implementation

When creating components:
- Check `src/components/` for similar components first
- If a component shares >50% logic with an existing one, consider extending or composing it
- Extract common patterns into base components or utilities
- Use props and composition to handle variations, not code duplication

---

## 13b. Folder Structure Philosophy

Cursor MUST respect the established folder structure:

- **Follow the defined structure** in section 3 unless explicitly instructed otherwise
- **Place files in their designated directories**:
  - Components → `src/components/`
  - Hooks → `src/hooks/`
  - Utilities → `src/lib/`
  - Types → `src/types/`
  - Pages → `src/app/`
  - Tests → `src/tests/` or `tests/`
- **Do NOT create new top-level directories** without explicit instruction
- **Do NOT mix concerns** - Keep components, utilities, and types separate
- **Use consistent naming conventions**:
  - Components: PascalCase (e.g., `DrinkListItem.tsx`)
  - Hooks: camelCase with `use` prefix (e.g., `useDrinkSearch.ts`)
  - Utilities: camelCase (e.g., `ingredientUtils.ts`)
  - Types: camelCase (e.g., `cocktail.ts`)
- **Group related files** - Keep related functionality together
- **Avoid deep nesting** - Prefer flat structures where possible (max 2-3 levels deep)

---

## 14. AI Usage Transparency

Cursor should favor:

- Small, incremental changes
- Clear commit-style reasoning
- Explain non-obvious decisions in comments ONLY when valuable

---

## 15. Architectural Philosophy

- **Separation of Concerns**: Clear boundaries between API layer, data normalization, UI components, and business logic.
- **Testability**: Structure code to be easily testable, especially pure functions and utilities.
- **Composability**: Build small, focused components that can be composed together.
- **Data Normalization**: Thoughtfully normalize API data early in the data flow, not in components.
- **Pragmatic Decisions**: Choose solutions that are maintainable and reviewable, not necessarily the most clever.
- **Graceful Degradation**: Handle missing or malformed data without crashing, but don't overbuild error handling.

---

## 16. Final Priority Order

1. Correctness vs PDF spec
2. Clean architecture
3. Type safety
4. Readability
5. Visual fidelity
6. Extras (tests, Storybook, deploy)

---

# End of Cursor Rules
